import re
import difflib
from typing import List
from config import AGGS_STR_ORDERED, OP2IDX
from utils import unformat_string, strip_specials


class SQLSanitizer:
    def __init__(self, fuzzymatch_threshold: float = 0.7):
        self.fuzzymatch_threshold = fuzzymatch_threshold

    def sanitize(self, sql_query: str, table: dict, verbose=0) -> str:
        """
        Sanitizes raw query generated by the model/reconstructed by sql dict from dataset and make the query functional

        Converts : SELECT Notes FROM table WHERE Current slogan = SOUTH AUSTRALIA
            To : SELECT `Notes` FROM table WHERE `Current slogan` = "SOUTH AUSTRALIA"

        sql_query(str): raw output generated by model without unformat_string() or strip_specials()
        """
        if verbose: print("\n")
        #  ---- For structured output only -----
        # Replaces braces/brackets special tokens to brackets and braces
        sql_query = unformat_string(sql_query)

        # Get rid of special tokens
        sql_query = strip_specials(sql_query)
        sql_query = sql_query.strip()

        # Check if already sanitized :
        if is_already_sanitized(sql_query, table):
            print("Query is already sanitized. Skipping re-sanitization.")
            return sql_query

        if sql_query.endswith(";"):
            sql_query = sql_query[:-1]

        # Check if SELECT is the only statement for guardrails
        first_statement = sql_query.split(' ')[0]
        if first_statement != 'SELECT':
            print("Detected non SELECT query. Replacing to SELECT for guardrails...")
        sql_query = sql_query.replace(first_statement, 'SELECT', 1)

        # Quote multiple SELECT columns
        sql_query = re.sub(r"SELECT\s+(.+?)\s+FROM", lambda x: quote_select_column(x,
                                                                                   table["header"],
                                                                                   fuzzymatch_threshold=self.fuzzymatch_threshold,
                                                                                   verbose=verbose
                                                                                   ),
                           sql_query)

        # Handle conditions
        matches = re.search(r"\bWHERE\b\s+(.+)", sql_query, flags=re.IGNORECASE)
        if matches:
            where_clause = matches.group(1)
            if verbose: print("where clause detected :", where_clause)
            sanitized_where = sanitize_where_conditions(where_clause,
                                                        table["header"],
                                                        fuzzymatch_threshold=self.fuzzymatch_threshold,
                                                        verbose=verbose)

            # sanitized_where can contain "\" character that can be interpreted as a regex pattern in f"WHERE {sanitized_where}" --> We use lambda _: f"WHERE {sanitized_where}"
            sql_query = re.sub(r"\bWHERE\b\s+.+", lambda _: f"WHERE {sanitized_where}", sql_query, flags=re.IGNORECASE)

        # Now we have something like """SELECT `Notes` FROM table WHERE `Current slogan` = "SOUTH AUSTRALIA" AND `Next slogan` < "AFRICA" OR `blabla blabla` > 2"""
        # Replace 'table' with the correct table_id
        table_id = "table_" + table["id"].replace("-", "_")
        matches = re.search(r"\bFROM\s+([A-Za-z0-9_`]+)(?=\s*(WHERE|GROUP|ORDER|LIMIT|$))", sql_query,
                            flags=re.IGNORECASE)
        if matches:
            table_name = matches.group(1)  #
            start, end = matches.span()
            sql_query = sql_query[:start + len(" FROM")] + table_id.strip() + sql_query[end:]

        if not sql_query.endswith(';'):
            sql_query += ';'

        return sql_query


def best_match_column(col: str, headers: List[str],
                      fuzzymatch_threshold: float = 0.7, verbose=0) -> str:
    """
    Given a raw column expression (possibly containing aggregates),
    return the best-matching header from the table schema.
    Note that this only handles unique column names.
    Handles fuzzy matching and commas inside column names.
    """

    # Normalize headers for case-insensitive lookup
    norm_headers = {h.lower(): h for h in headers}

    candidate = col.strip()

    # Exact match (case-insensitive)
    if candidate.lower() in norm_headers:
        matched = norm_headers[candidate.lower()]
        if verbose: print(f"Detected column (exact match): {matched}")
        return matched

    # Fuzzy match
    best_match = difflib.get_close_matches(candidate.lower(), norm_headers.keys(), n=1, cutoff=fuzzymatch_threshold)
    if best_match:
        matched = norm_headers[best_match[0]]
        if verbose: print(f"Fuzzy match for column '{candidate}' → '{matched}'")
        return matched

    # Fallback literal
    if verbose: print(f"No match found for column '{candidate}', using literal")
    return candidate


def quote_select_column(match, headers: List[str], fuzzymatch_threshold=0.7,
                        verbose=0):
    """
    Sanitizes the SELECT part by detecting aggregates first,
    then matching the true column name via schema or fuzzy logic.
    """

    raw_expr = match.group(1).strip()

    # Step 1: Recursively detect aggregates from the start
    aggs = []
    while True:
        m = re.match(rf"^\s*({'|'.join(AGGS_STR_ORDERED)})\b", raw_expr, flags=re.IGNORECASE)  # Match aggregate
        if not m:
            break
        aggs.append(m.group(1).upper())

        # remove the matched aggregate and any spaces
        raw_expr = re.sub(rf"^\s*{m.group(1)}\b\s*", "", raw_expr, flags=re.IGNORECASE)

    # Step 2: match column name against schema
    col = best_match_column(raw_expr, headers, fuzzymatch_threshold,
                            verbose=verbose)
    col = col.strip()
    if not (col.startswith("`") and col.endswith("`")):
        col = f"`{col}`"

    # Step 3: rebuild expression with aggregates
    expr = col

    if len(aggs) >= 2 and aggs[0] == "COUNT" and aggs[1] == "DISTINCT":
        expr = f"COUNT(DISTINCT({col}))"
    else:
        for agg in aggs[::-1]:
            expr = f"{agg}({expr})"

    return f"SELECT {expr} FROM"


def sanitize_where_conditions(where_clause: str, headers: List[str], fuzzymatch_threshold: float = 0.7,
                              verbose=0) -> str:
    """
    Takes the raw text after 'WHERE' and returns a cleaned SQL WHERE clause
    with quoted column names and string literals.
    Supports multiple conditions joined by AND/OR.
    """
    # Split on AND/OR, keeping delimiters
    parts = re.split(r"\b(AND|OR)\b", where_clause)
    sanitized_parts = []

    # parts = ['Top-5 < 1 ', 'AND', ' Top-25 > 1']
    if verbose: print("Parts of where clause: ", parts)

    for part in parts:
        part = part.strip()
        if part in {"AND", "OR"}:
            sanitized_parts.append(part)
            continue

        # Match column operator value triplets
        m = re.match(
            rf"^(.+?)\s*({'|'.join(map(re.escape, OP2IDX.keys()))})\s*(.+)$",
            # rf"^([-–—#.A-Za-z0-9_ /]+)\s*({'|'.join(map(re.escape, list(OP2IDX.keys())))})\s*(.+)$", # Columns can contain hyphens or #
            part
        )
        if not m:
            sanitized_parts.append(part)
            continue

        col, op, val = m.groups()
        col = col.strip()
        val = val.strip()
        if verbose:
            print(f"Detected from where clause part '{part}' :\n\tcol: {col}, op: {op}, val: {val}")

        # Quote column if not already quoted
        col = best_match_column(col, headers, fuzzymatch_threshold=0.7,
                                verbose=verbose)
        if not (col.startswith("`") and col.endswith("`")):
            col = f"`{col}`"

        # Detect string literal: quote if not number or already quoted
        if not re.match(r'^[0-9.\-]+$', val):
            if val.strip().startswith('"') and val.strip().endswith('"'):
                val = val.strip()
            else:
                val = f'"{val}"'

        sanitized_parts.append(f"{col} {op} {val}")

    # Reassemble full WHERE clause
    return " ".join(sanitized_parts)


def is_already_sanitized(sql_query: str, table: dict) -> bool:
    """
    Checks if the SQL query already appears sanitized and correctly formatted.
    """
    # Must start with SELECT
    if not sql_query.strip().upper().startswith("SELECT"):
        return False

    # Must contain FROM and semicolon
    if "FROM" not in sql_query.upper() or not sql_query.strip().endswith(";"):
        return False

    # Must use the correct table_id
    expected_table_id = "table_" + table["id"].replace("-", "_")
    if expected_table_id not in sql_query:
        return False

    # Columns should be properly backticked if they contain spaces or keywords
    # We look for suspicious patterns like nested backticks
    if re.search(r"`\s*`", sql_query):  # double backtick or malformed
        return False

    # Avoid double quoting: MIN(`(`Left`)`)
    if re.search(r"`\(`", sql_query):
        return False

    return True
